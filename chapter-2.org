#+TITLE: SICP Chapter 2
#+STARTUP: overview
#+STARTUP: indent
#+PROPERTY: header-args :noweb yes
#+PROPERTY: header-args:racket :lang racket

* Preset
To execute code blocks in this file, you need ~ob-racket~ installed.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
(use-package racket-mode)
(use-package ob-racket
  :load-path "~/.emacs.d/packages"
  :after org
  :pin manual
  :config
  (append '((racket . t) (scribble . t)) org-babel-load-languages))
#+END_SRC

#+RESULTS:
: t

#+NAME: nil
#+BEGIN_SRC racket
(define nil '())
#+END_SRC

* Chapter 2 Building Abstractions with Data
:PROPERTIES:
:VISIBILITY: children
:END:
** 2.1 Introduction to Data Abstraction
*** Exercise 2.1                                                   :solved:
**** Answer
#+BEGIN_SRC racket
(define (make-rat n d)
  (if (< d 0)
      (cons (- n) (- d)) 
      (cons n d))) 
#+END_SRC

*** Exercise 2.2                                                   :solved:
**** Preset
#+NAME: print-point
#+BEGIN_SRC racket
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+END_SRC

**** Answer
#+NAME: midpoint-segment
#+BEGIN_SRC racket
(define make-segment cons)
(define start-segment car)
(define end-segment cdr)
(define make-point cons)
(define x-point car)
(define y-point cdr)

(define (avg2 x y) (/ (+ x y) 2))

(define (midpoint-segment seg)
  (define start (start-segment seg))
  (define start-x (x-point start))
  (define start-y (y-point start))
  (define end (end-segment seg))
  (define end-x (x-point end))
  (define end-y (y-point end))
  (make-point (avg2 start-x end-x) (avg2 start-y end-y)))
#+END_SRC

#+BEGIN_SRC racket
<<print-point>>
<<midpoint-segment>>

(print-point
 (midpoint-segment
  (make-segment
   (make-point 1.5 1)
   (make-point 3 3))))
#+END_SRC

#+RESULTS:
: 
: (2.25,2)

*** Exercise 2.3                                                   :solved:
**** Answer
First representation:
#+NAME: make-rect-1
#+BEGIN_SRC racket
(define (make-rect a b c d) (cons a (cons b (cons c d))))

(define (a-rect rect) (car rect))
(define (b-rect rect) (cadr rect))
(define (c-rect rect) (caddr rect))
(define (d-rect rect) (cdddr rect))
#+END_SRC

Another representation:
#+NAME: make-rect-2
#+BEGIN_SRC racket
(define (make-rect a b c d) (cons a (cons b (cons c (cons d '())))))

(define (a-rect rect) (car rect))
(define (b-rect rect) (cadr rect))
(define (c-rect rect) (caddr rect))
(define (d-rect rect) (cadddr rect))
#+END_SRC

#+NAME: peri-rect
#+BEGIN_SRC racket
(define (square n) (* n n))

(define (distance a b)
  (define x-a (x-point a))
  (define y-a (y-point a))
  (define x-b (x-point b))
  (define y-b (y-point b))
  (sqrt (+ (square (- x-a x-b)) (square (- y-a y-b)))))

(define (peri-rect rect)
  (define a (a-rect rect))
  (define b (b-rect rect))
  (define c (c-rect rect))
  (define d (d-rect rect))
  (+ (distance a b) (distance b c) (distance c d) (distance d a)))
#+END_SRC

Validate the 1st representation:
#+BEGIN_SRC racket
<<make-rect-1>>
<<midpoint-segment>>
<<peri-rect>>

(define rect (make-rect
              (make-point 0 0)
              (make-point 0 1)
              (make-point 2 1)
              (make-point 2 0)))

(peri-rect rect)
#+END_SRC

#+RESULTS:
: 6

Validate the 2nd representation:
#+BEGIN_SRC racket
<<make-rect-2>>
<<midpoint-segment>>
<<peri-rect>>

(define rect (make-rect
              (make-point 0 0)
              (make-point 0 1)
              (make-point 2 1)
              (make-point 2 0)))

(peri-rect rect)
#+END_SRC

#+RESULTS:
: 6

*** Exercise 2.4                                                   :solved:
**** Preset

#+NAME: cons-car
#+BEGIN_SRC racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
#+END_SRC
**** Answer
For given X and Y, ~(cons X Y)~ equals to
~(lambda (m) X Y)~. Calling ~(car (cons X Y))~, is calling
~((lambda (m) (m X Y)) (lambda (p q) p))~, which is calling
~((lambda (p q) p) X Y)~, and yields X. 
Thus this definition fulfills that:
#+BEGIN_QUOTE
For any objects x and y, if z is ~(cons x y)~ then ~(car z)~
is x and ~(cdr z)~ is y.
#+END_QUOTE

~cdr~ definition:
#+BEGIN_SRC racket
<<cons-car>>
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons 2 1))
#+END_SRC

#+RESULTS:
: 1

*** Exercise 2.5                                                   :solved:
**** Answer
#+BEGIN_SRC racket
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))
(define (car p)
  (let-values ([(q r) (quotient/remainder p 2)])
    (cond [(= q 0) 0]
          [(= r 0) (+ (car q) 1)]
          [else  0])))
(define (z-cdr p)
  (let-values ([(q r) (quotient/remainder p 3)])
    (cond [(= q 0) 0]
          [(= r 0) (+ (cdr q) 1)]
          [else  0])))

(car (cons 3 4))
#+END_SRC

#+RESULTS:
: 3

*** Exercise 2.6                                                   :solved:
**** Answer
#+BEGIN_VERSE
Forgive me for using Haskell-style function annotation here.
First we have:

add-1 n = f -> x -> f ((n f) x)
      0 = f -> x -> x

We can get:

1 = add-1 0
  = f -> x -> f ((0 f) x)
  = f -> x -> f x
  
2 = add-1 1
  = f -> x -> f ((1 f) x)
  = f -> x -> f (f x)

We can guess out that:

n = f -> x -> f^n x

add m n = f -> x -> f^m (f^n x)
        = f -> x -> m f (n f x)

Now we have the direct definition of ~add~, that is:

add = m -> n -> f -> x -> m f (n f x)

Validate this:

add 1 1 = f -> x -> 1 f (1 f x)
        = f -> x -> f(f(x))
        = 2
#+END_VERSE

#+BEGIN_SRC racket
(define one
  (lambda (f)
    (lambda (x)
      (f x))))

(define two
  (lambda (f)
    (lambda (x)
      (f (f x)))))

(define (add m n)
  (lambda (f)
    (lambda (x) ((m f) ((n f) x)))))

;; A validate function
;; As we know n f x = f^n x, if f = this vf, then
;; vf x = vf^n x, so if we call n vf 0, it should simply
;; yields n
(define (vf a) (+ 1 a))

(((add one two) vf) 0)
#+END_SRC

#+RESULTS:
: 3

*** Exercise 2.7                                                   :solved:
**** Preset
#+NAME: e-2-7-a
#+BEGIN_SRC racket
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
#+END_SRC

#+NAME: e-2-7-b
#+BEGIN_SRC racket
(define (make-interval a b) (cons a b))
#+END_SRC

**** Answer
#+NAME: e-2-7-c
#+BEGIN_SRC racket
(define (lower-bound interval)
  (car interval))

(define (upper-bound interval)
  (cdr interval))
#+END_SRC

*** Exercise 2.8                                                   :solved:
**** Answer
The difference of two intervals should equal to the first
interval plus the negative of the second interval.

#+NAME: e-2-8
#+BEGIN_SRC racket 
<<e-2-7-a>>
<<e-2-7-b>>
<<e-2-7-c>>

(require racket/format)

(define (show a)
  (~a "[" (lower-bound a) ", " (upper-bound a) "]"))

(define (neg-interval a)
  (make-interval
   (- (upper-bound a))
   (- (lower-bound a))))

(define (sub-interval a b)
  (add-interval a (neg-interval b)))

(show (sub-interval (make-interval 1 2)  (make-interval 1 2)))
#+END_SRC

#+RESULTS: e-2-8
: [-1, 1]

*** Exercise 2.9                                                   :solved:
**** Answer
#+BEGIN_VERSE
For any tow intervals I0 and I1,
if I0 = [a, b]
   I1 = [x, y]
then width(I0) = (b - a) / 2
     width(I1) = (y - x) / 2
width(I0 + I1) = width([a + x, b + y])
               = ((b + y) - (a + x)) / 2
               = (b - a) / 2 + (y - x) / 2
               = width(I0) + width(I1)
Thus width(I0 + I1) = width(I0) + width(I1)

For example, I0 = [0, 0], I1 = [0, 1],
width(I0) = 0, width(I1) = 0.5,
width(I0 * I1) = width([0, 1]) = 0.5 != with(I0) * width(I1)
#+END_VERSE     

*** Exercise 2.10                                                  :solved:
**** Answer
#+NAME: e-2-10
#+BEGIN_SRC racket
<<e-2-8>>

(define (div-interval x y)
  (if (<= (* (lower-bound y) (upper-bound y)) 0)
      (error "Interval Spans Zero")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(show (div-interval (make-interval 1 2) (make-interval 1 1)))
#+END_SRC

#+RESULTS: e-2-10
: [1.0, 2.0]

*** Exercise 2.11                                                  :solved:
**** Answer
#+NAME: e-2-11
#+BEGIN_SRC racket
<<e-2-10>>

(define (mul-interval x y)
  (let ((lX (lower-bound x))
        (uX (upper-bound x))
        (lY (lower-bound y))
        (uY (upper-bound y)))
    (cond ((> lX 0) (cond ((> 0 lY) (make-interval (* lX lY) (* uX uY)))
                          ((< 0 uY) (make-interval (* lY uX) (* lX uY)))
                          (else (make-interval (* lY uX) (* uX uY)))))

          ((< lX 0) (cond ((< 0 uY) (make-interval (* uX uY) (* lX lY)))
                          ((> 0 lY) (make-interval (* lX uY) (* uX lY)))
			  (else (make-intervel (* lX uY) (* lx ly)))))

          (else (cond ((> 0 lY) (make-interval (* lX uY) (* uX uY)))
                      ((< 0 uY) (make-intervel (* lY uX) (* lX lY)))
                      (else (make-interval
                             (min (* lX uY) (* lY uX))
                             (max (* lX lY) (* ux uY)))))))))

(show (mul-interval (make-interval -3 -2) (make-interval 2 3)))
#+END_SRC

#+RESULTS: e-2-10-b
: [-6, -6]

*** Exercise 2.12                                                  :solved:
**** Preset
#+NAME: e-2-12-a
#+BEGIN_SRC racket
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

**** Answer
#+NAME: e-2-12-b
#+BEGIN_SRC racket
<<e-2-11>>
<<e-2-12-a>>

(define (make-center-percent c p)
  (make-center-width c (* (abs c) (/ p 100))))

(define (percent a)
  (* (/ (width a) (center a)) 100))

(show (make-center-percent 1 50))
(percent (make-center-percent 1 50))
#+END_SRC

#+RESULTS:
: 50

*** Exercise 2.13                                                  :solved:
**** Answer
#+BEGIN_VERSE
For any two intervals I0 and I1,

I0 = C0 ± P0 = [C0 - C0 * P0, C0 + C0 * P0]
I1 = C1 ± P1 = [C1 - C1 * P1, C1 + C1 * P1]

For All numbers are positive,

I = I0 * I1 
I = C ± P
C = C0 * C1 + P0 * P1
P = C0 * P1 + C1 * P0

R = P / C = (C0 * P1 + C1 * P0) / (C0 * C1 + P0 * P1)
  = (C0 / P0 + C1 / P1) / ((C0 * C1) / (P0 * P1) + 1)
  = (R0 + R1) / (R0 * R1 + 1)
#+END_VERSE

*** Exercise 2.14
After considerable work, Alyssa P. Hacker delivers her finished
system. Several years later, after she has forgotten all about
it, she gets a frenzied call from an irate user, Lem E. Tweakit.
It seems that Lem has noticed that the formula for parallel
resistors can be written in two algebraically equivalent ways:
=(R1 * R2) / (R1 + R2)= and =1 / (1 / R1 + 1 / R2)=.

He has written the following two programs, each of which
computes the parallel-resistors formula differently:

#+NAME: e-2-13
#+BEGIN_SRC scheme
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
#+END_SRC

Lem complains that Alyssa’s program gives different answers for
the two ways of computing. Thisis is a serious complaint.

Demonstrate that Lem is right. Investigate the behavior of the
system on a variety of arithmetic expressions. Make some
intervals A and B, and use them in computing the expressions
=A / A= and =A / B=. You will get the most insight by using
intervals whose width is a small percentage of the center value.
Examine the results of the computation in center-percent form
(see Exercise 2.12).

*** Exercise 2.15
Eva Lu Ator, another user, has also noticed the different
intervals computed by different but algebraically equivalent
expressions. She says that a formula to compute with intervals
using Alyssa’s system will produce tighter error bounds if it
can be writtten in such a form that no variable that represents
an uncertain number is repeated. Thus, she says, ~par2~ is a
“better” program for parallel resistances than ~par1~. Is she
right? Why?

*** Exercise 2.16
Explain, in general, why equivalent algebraic expressions may
lead to different answers. Can you devise an interval-arithmetic
package that does not have this shortcoming, or is this task
impossible? (Warning: This is problem is very difficult.)

** 2.2 Hierarchical Data and the Closure Property
*** Exercise 2.17                                                  :solved:
**** Answer
#+BEGIN_SRC racket :lang racket
(define (last-pair list)
  (if (null? (cdr list))
      (car list)
      (last-pair (cdr list))))

(last-pair (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: 4

*** Exercise 2.18                                                  :solved:
**** Answer
#+BEGIN_SRC racket :lang racket
<<nil>>

(define (reverse-iter list result)
  (cond [(null? list) result]
        [(null? (cdr list)) (cons (car list) result)]
        [else (reverse-iter
	       (cdr list) 
	       (cons (car list) result))]))

(define (reverse list)
  (reverse-iter list nil))

(reverse (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 2 | 1 |

*** Exercise 2.19
Consider the change-counting program of Section 1.2.2. It would
be nice to be able to easily change the currency used by the
program, so that we could compute the number of ways to change a
British pound, for example. As the program is written, the
knowledge of the currency is distributed partly into the
procedure ~first-denomination~ and partly into the procedure
~count-change~ (which knows that there are five kinds of U.S.
coins). It would be nicer to be able to supply a list of coins
to be used for making change.

We want to rewrite the procedure cc so that its second argument
is a list of the values of the coins to use rather than an
integer specifying which coins to use. We could then have lists
that defined each kind of currency:

#+BEGIN_SRC racket :lang racket
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

We could then call cc as follows:

#+BEGIN_SRC racket :lang racket
(cc 100 us-coins)
#+END_SRC

To do this will require changing the program =cc= somewhat. It
will still have the same form, but it will access its second
argument differently, as follows:

#+BEGIN_SRC racket :lang racket
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
#+END_SRC

Define the procedures ~first-denomination~, ~except-first-
denomination~, and ~no-more?~ in terms of primitive operations
on list structures. Does the order of the list ~coin-values~
affect the answer produced by ~cc~? Why or why not?

*** Exercise 2.20                                                  :solved:
**** Answer
#+BEGIN_SRC racket
(define (same-parity-iter parity lst)
  (cond [(empty? lst) lst]
        [(eq? (remainder (car lst) 2) parity)
         (cons (car lst) (same-parity-iter parity (cdr lst)))]
        [else (same-parity-iter parity (cdr lst))]))

(define (same-parity . l)
  (same-parity-iter (remainder (car l) 2) l))

(same-parity 1 2 3 4 5)
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 |

*** Exercise 2.21                                                  :solved:
**** Answer
#+BEGIN_SRC racket 
(define (square-list items)
  (if (null? items)
      '()
      (cons (* (car items) (car items)) (square-list (cdr items)))))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

#+BEGIN_SRC racket 
(define (square-list items)
  (map (lambda (n) (* n n)) items))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

*** Exercise 2.22                                                  :solved:
**** Answer
Because when you do ~(cons (square (car things)) answer)~, you
are putting ~(square (car things))~ to the head of answer. It
will act like a 'FILO' stack.

For the second program, ~answer~ is a list, however
~(square (car things))~ is a number, ~(cons list number)~
creates a structure like ~(((nil . 1) . 4) . 9)~, which is not
a list.

*** Exercise 2.23                                                  :solved:
**** Answer
#+BEGIN_SRC racket
(define (for-each f lst)
  (if (empty? lst)
      #t
      (begin
        (f (car lst))
        (for-each f (cdr lst)))))

(for-each (lambda (x) (display x)) (list 57 321 88))
#+END_SRC

#+RESULTS:
: 5732188#t

*** Exercise 2.24                                                  :solved:
**** Answer
The output is:
#+BEGIN_SRC racket :lang racket
(1 . ((2 . ((3 . (4 . nil)) . nil) ) . nil)
#+END_SRC

The box and pointer graph:
#+BEGIN_VERSE
[ 1 | -] -> [ ↓ | nil ]
            [ 2 | -] -> [ ↓ | nil ]
                        [ 3 | -] -> [ 4 | nil]
#+END_VERSE

The tree graph:
#+BEGIN_VERSE
 .
 |-+
 1 |-+-+
   2 | |
     3 4
#+END_VERSE 

*** Exercise 2.25                                                  :solved:
**** Answer
#+BEGIN_SRC racket
(define (solve l)
  (cadr (caddr l)))

(solve (list 1 3 (list 5 7) 9))
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC racket
(define (solve l)
  (car (car l)))

(solve (list (list 7)))
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC racket :lang racket
(define (solve l)
  (cadr (cadr (cadr (cadr (cadr (cadr l)))))))

(solve (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
#+END_SRC

#+RESULTS:
: 7

*** Exercise 2.26                                                  :solved:
**** Preset
#+NAME: e-2-26-a
#+BEGIN_SRC racket
(define x (list 1 2 3))
(define y (list 4 5 6))
#+END_SRC

#+NAME: e-2-26-b
#+BEGIN_SRC racket
(append x y)
(cons x y)
(list x y)
#+END_SRC

**** Answer
The output is:

#+BEGIN_SRC racket
(list 1 2 3 4 5 6)
((list 1 2 3) . (list 4 5 6))
((list 1 2 3) . ((list 4 5 6) . nil))
#+END_SRC

To check it:

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(append x y)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 |

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(cons x y)
#+END_SRC

#+RESULTS:
| (1 2 3) | 4 | 5 | 6 |

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(list x y)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
| 4 | 5 | 6 |

*** Exercise 2.27                                                  :solved:
**** Answer
#+BEGIN_SRC racket
(define (reverse-iter lst reversed)
  (cond [(empty? lst) reversed]
        [(empty? (cdr lst))
         (if (pair? (car lst))
             (cons (reverse-iter (car lst) '()) reversed)
             (cons (car lst) reversed))]
        [else
         (if (pair? (car lst))
             (reverse-iter (cdr lst) 
                           (cons (reverse-iter (car lst) '()) reversed))
             (reverse-iter (cdr lst) (cons (car lst) reversed)))]))

(define (deep-reverse lst) (reverse-iter lst '()))

(deep-reverse (list 1 (list 2 3) 4 5 (list 6 7 8)) )
#+END_SRC

#+RESULTS:
| (8 7 6) | 5 | 4 | (3 2) | 1 |

*** Exercise 2.28                                                  :solved:
**** Answer
#+BEGIN_SRC racket
(define (fringe-iter tree result)
  (cond [(empty? tree) result]
        [(pair? (car tree))
         (append (append result (fringe-iter (car tree) '())) 
                 (fringe-iter (cdr tree) '()))]
        [else (fringe-iter (cdr tree) (append result (list (car tree))))]))

(define (fringe tree)
  (fringe-iter tree '()))

(fringe (list (list 1 2) 3 (list 4 5)))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

*** Exercise 2.29                                                  :solved:
**** Preset
#+NAME: e-2-29-a
#+BEGIN_SRC racket
(define (make-mobile left right)
  (list left right))
#+END_SRC

#+NAME: e-2-29-b
#+BEGIN_SRC racket
(define (make-branch length structure)
  (list length structure))
#+END_SRC

#+NAME: e-2-29-c
#+BEGIN_SRC racket
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
#+END_SRC
**** Answer
***** a
#+NAME: e-2-29-d
#+BEGIN_SRC racket
(define (left-branch mob) (car mob))
(define (right-branch mob) (cadr mob))
(define (branch-length brn) (car brn))
(define (branch-structure brn) (cadr brn))
#+END_SRC

***** b
#+NAME: e-2-29-e
#+BEGIN_SRC racket
<<e-2-29-a>>
<<e-2-29-b>>
<<e-2-29-d>>

(define (brn-weight brn)
  (let ([strc (branch-structure brn)])
    (if (number? strc)
        strc
        (total-weight strc))))

(define (total-weight mob)
  (+
   (brn-weight (left-branch mob))
   (brn-weight (right-branch mob))))

(total-weight
 (make-mobile
  (make-branch 1 2)
  (make-branch
   3
   (make-mobile (make-branch 7 8) (make-branch 9 10)))))
#+END_SRC

#+RESULTS: e-2-29-e
: 20

***** c
#+NAME: e-2-29-f
#+BEGIN_SRC racket
<<e-2-29-e>>

(define (brn-balanced? brn)
  (let ([strc (branch-structure brn)])
    (if (number? strc)
        #t
        (balanced? strc))))

(define (torque brn)
  (* (branch-length brn) (brn-weight brn)))

(define (balanced? mob)
  (and
   (= (torque (left-branch mob))
      (torque (right-branch mob)))
   (brn-balanced? (left-branch mob))
   (brn-balanced? (right-branch mob))))

(balanced?
 (make-mobile
  (make-branch 1 20)
  (make-branch 2
               (make-mobile
                (make-branch 1 5)
                (make-branch 1 5)))))
#+END_SRC

#+RESULTS: e-2-29-f
: #t

***** d
I only need to change the selectors and constructors, which
are ~left-branch~, ~right-branch~, ~branch-length~ and
~branch-structure~ functions.

*** Exercise 2.30                                                  :solved:
**** Answer
Implement directly:

#+BEGIN_SRC racket
(define (square n) (* n n))

(define (square-tree tree)
  (cond [(empty? tree) '()]
        [(not (pair? tree)) (square tree)]
        [else (cons (square-tree (car tree))
                    (square-tree (cdr tree)))]))

(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

Implement with ~map~:

#+BEGIN_SRC racket
(define (square n) (* n n))

(define (square-tree tree)
  (map (lambda (sub)
         (if (pair? sub)
             (square-tree sub)
             (square sub)))
       tree))

(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

*** Exercise 2.31                                                  :solved:
**** Preset
#+NAME: e-2-31-a
#+BEGIN_SRC racket
(define (square-tree tree) (tree-map square tree))
#+END_SRC
**** Answer
#+BEGIN_SRC racket
<<e-2-31-a>>

(define (square n) (* n n))

(define (tree-map f tree)
  (map (lambda (sub)
         (if (pair? sub)
             (tree-map f sub)
             (f sub)))
       tree))

(square-tree (list 1 2 (list 3 4)))
#+END_SRC

#+RESULTS:
| 1 | 4 | (9 16) |

*** Exercise 2.32                                                  :solved:
**** Answer

#+BEGIN_SRC racket
(define nil '())

(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))])
        (append rest (map (lambda (n) (cons (car s) n)) rest)))))

(subsets (list 1 2 3))
#+END_SRC

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

*** Exercise 2.33                                                  :solved:
**** Answer
Just put the definition of ~accumulate~ here:

#+NAME: accumulate
#+BEGIN_SRC racket
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
#+END_SRC

#+BEGIN_SRC racket
<<accumulate>>

(define (map p sequence)
  (accumulate
   (lambda (x y) (cons (p x) y))
   '()
   sequence))

(map (lambda (n) (+ 1 n)) (list 1 2 3))
#+END_SRC

#+RESULTS:
| 2 | 3 | 4 |

#+BEGIN_SRC racket
<<accumulate>>

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(append (list 1 2) (list 3 4))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 |

#+BEGIN_SRC racket
<<accumulate>>

(define (length sequence)
  (accumulate (lambda (e n) (+ 1 n)) 0 sequence))

(length (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: 4

*** Exercise 2.34                                                  :solved:
**** Answer

#+BEGIN_SRC racket
<<accumulate>>

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff (* higher-terms x)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+RESULTS:
: 79


*** Exercise 2.35                                                  :solved:
**** Answer

#+BEGIN_SRC racket
<<accumulate>>

(define (count-leaves t)
  (accumulate
   (lambda (x y) (+ x y))
   0
   (map (lambda (n) (if (pair? n) (count-leaves n) 1)) t)))

(count-leaves (list 1 2 3 (list 4 5)))
#+END_SRC

#+RESULTS:
: 5

*** Exercise 2.36                                                  :solved:
**** Answer
#+NAME: accumulate-n
#+BEGIN_SRC racket
<<nil>>
<<accumulate>>

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

#+END_SRC

#+BEGIN_SRC racket
<<accumulate-n>>
(define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(accumulate-n + 0 s)
#+END_SRC

#+RESULTS:
| 22 | 26 | 30 |

*** Exercise 2.37                                                  :solved:
**** Preset
#+NAME: dot-product
#+BEGIN_SRC racket
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
#+END_SRC
**** Answer

#+NAME: e-2-37
#+BEGIN_SRC racket
<<accumulate-n>>
<<dot-product>>

(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))

(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row) (matrix-*-vector cols row))  m)))
#+END_SRC

#+RESULTS:
|  7 |  7 |
| 14 | 14 |

#+BEGIN_SRC racket
<<e-2-37>>
(define m (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
(matrix-*-vector m (list 2 3 4 5))
#+END_SRC

#+RESULTS:
| 40 | 77 | 110 |

#+BEGIN_SRC racket
<<e-2-37>>
(define m (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
(transpose m)
#+END_SRC

#+RESULTS:
| 1 | 4 | 6 |
| 2 | 5 | 7 |
| 3 | 6 | 8 |
| 4 | 6 | 9 |

#+BEGIN_SRC racket
<<e-2-37>>
(matrix-*-matrix (list (list 1 1) (list 2 2)) (list (list 3 3) (list 4 4)))
#+END_SRC

#+RESULTS:
|  7 |  7 |
| 14 | 14 |

*** Exercise 2.38                                                  :solved:
**** Preset
#+NAME: fold-left
#+BEGIN_SRC racket
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC
**** Answer
The values are: ~3 / 2~, ~1 / 6~, ~(1 (2 (3 nil)))~,
~(((nil 1) 2) 3)~.

An ~op~ should satisfy that ~(op x y) = (op y x)~ to guarantee
that ~fold-right~ and ~fold-left~ will produce same values.

*** Exercise 2.39                                                  :solved:
**** Answer
#+BEGIN_SRC racket
<<nil>>
<<accumulate>>
<<fold-left>>
(define fold-right accumulate)

(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))

(reverse (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 4 | 3 | 2 | 1 |

#+BEGIN_SRC racket
<<nil>>
<<accumulate>>
<<fold-left>>
(define fold-right accumulate)

(define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) nil sequence))

(reverse (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 4 | 3 | 2 | 1 |

*** Exercise 2.40                                                  :solved:
**** Preset
#+NAME: flatmap
#+BEGIN_SRC racket
(define (flatmap proc seq)
  (foldr append nil (map proc seq)))
#+END_SRC

#+NAME: enumerate-interval
#+BEGIN_SRC racket
(define (enumerate-interval i j)
  (cond [(< i j) (cons i (enumerate-interval (+ i 1) j))]
        [(= i j) (cons i nil)]
        [else nil]))
#+END_SRC

**** Answer
#+BEGIN_SRC racket
<<nil>>
<<accumulate>>
<<flatmap>>
<<enumerate-interval>>

(define (unique-pairs n)
  (define is (enumerate-interval 1 n))
  (flatmap (lambda (i)
             (define js (enumerate-interval 1 (- i 1)))
             (map (lambda (j) (list i j)) js)) is))

(unique-pairs 6)
#+END_SRC

#+RESULTS:
| 2 | 1 |
| 3 | 1 |
| 3 | 2 |
| 4 | 1 |
| 4 | 2 |
| 4 | 3 |
| 5 | 1 |
| 5 | 2 |
| 5 | 3 |
| 5 | 4 |
| 6 | 1 |
| 6 | 2 |
| 6 | 3 |
| 6 | 4 |
| 6 | 5 |

The definition of ~prime-sum-pairs~ can be simplified to:

#+BEGIN_SRC racket
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (unique-pairs n))))
#+END_SRC


*** Exercise 2.41                                                  :solved:
**** Answer
#+BEGIN_SRC racket
<<nil>>
<<flatmap>>
<<enumerate-interval>>

(define (unique-triples n)
  (define is (enumerate-interval 1 n))
  (flatmap (lambda (i)
             (define js (enumerate-interval 1 (- i 1)))
             (flatmap (lambda (j)
                        (define ks (enumerate-interval 1 (- j 1)))
                        (map (lambda (k) (list i j k)) ks)) js)) is))

(define (filter-triples n s)
  (define triples (unique-triples n))
  (define (condition lst)
    (define sum (foldr + 0 lst))
    (= sum s))
  (filter condition triples))

(filter-triples 6 8)
#+END_SRC

#+RESULTS:
| 4 | 3 | 1 |
| 5 | 2 | 1 |


*** Exercise 2.42                                                  :solved:
**** Preset
#+NAME: queens
#+BEGIN_SRC racket
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
#+END_SRC

**** Answer
#+BEGIN_SRC racket
(define (make-queen col row) (cons col row))
(define col-queen car)
(define row-queen cdr)

(define (check? q-a q-b)
  (define col-a (col-queen q-a))
  (define row-a (row-queen q-a))
  (define col-b (col-queen q-b))
  (define row-b (row-queen q-b))
  (define col-diff (- col-a col-b))
  (define row-diff (- row-a row-b))
  (or (= col-diff 0)
      (= row-diff 0)
      (= (abs col-diff) (abs row-diff))))

(define empty-board '())

(define (adjoin-position row size positions)
  (cons (make-queen size row) positions))

(define (safe? size positions)
  (cond [(empty? positions) #t]
        [(empty? (cdr positions)) #t]
        [else (foldl
               (lambda (q result)
                 (and (not (check? q (car positions))) result))
               #t (cdr positions))]))

<<nil>>
<<flatmap>>
<<enumerate-interval>>
<<queens>>

(queens 5)
#+END_SRC

#+RESULTS:
| (5 . 4) | (4 . 2) | (3 . 5) | (2 . 3) | (1 . 1) |
| (5 . 3) | (4 . 5) | (3 . 2) | (2 . 4) | (1 . 1) |
| (5 . 5) | (4 . 3) | (3 . 1) | (2 . 4) | (1 . 2) |
| (5 . 4) | (4 . 1) | (3 . 3) | (2 . 5) | (1 . 2) |
| (5 . 5) | (4 . 2) | (3 . 4) | (2 . 1) | (1 . 3) |
| (5 . 1) | (4 . 4) | (3 . 2) | (2 . 5) | (1 . 3) |
| (5 . 2) | (4 . 5) | (3 . 3) | (2 . 1) | (1 . 4) |
| (5 . 1) | (4 . 3) | (3 . 5) | (2 . 2) | (1 . 4) |
| (5 . 3) | (4 . 1) | (3 . 4) | (2 . 2) | (1 . 5) |
| (5 . 2) | (4 . 4) | (3 . 1) | (2 . 3) | (1 . 5) |

*** Exercise 2.43
**** Answer
