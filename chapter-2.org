#+TITLE: SICP Chapter 2
#+STARTUP: overview
#+STARTUP: indent
#+PROPERTY: header-args :noweb yes
#+PROPERTY: header-args:racket :lang racket

* Preset
To execute code blocks in this file, you need ~ob-racket~ installed.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
(use-package racket-mode)
(use-package ob-racket
  :load-path "~/.emacs.d/packages"
  :after org
  :pin manual
  :config
  (append '((racket . t) (scribble . t)) org-babel-load-languages))
#+END_SRC

#+RESULTS:
: t

* Chapter 2 Building Abstractions with Data
:PROPERTIES:
:VISIBILITY: children
:END:
** 2.1 Introduction to Data Abstraction
*** Exercise 2.2
Consider the problem of representing line segments in a plane. Each
segment is represented as a pair of points: a starting point and an
ending point. Define a constructor ~make-segment~ and selectors
~start-segment~ and ~end-segment~ that define the representation of
segments in terms of points. Furtihermore, a point can be represented
as a pair of numbers: the x coordinate and the y coordinate.
Accordingly, specify a constructor ~make-point~ and selectors
~x-point~ and ~y-point~ that define this representation. Finally,
using your selectors and constructors, define a procedure
~midpoint-segment~ that takes a line segment as argument and returns
its midpoint (the point whose coordinates are the average of the
coordinates of the endpoints). To try your procedures, you’ll need a
way to print points:

#+BEGIN_SRC emacs-lisp :session e-2-2

(defun print-point (p)
  (format "(%s, %s)" (x-point p) (y-point p)))

(defalias 'make-segment 'cons)

(defun start-segment (p)
  (car p))

(defun end-segment (p)
  (cdr p))

(defun make-point (x y)
  (cons x y))

(defalias 'x-point 'car)
(defalias 'y-point 'cdr)

(defun avg (x y) (/ (+ x y) 2.0))

(defun midpoint-segment (seg)
  (let ((start (start-segment seg))
        (end (end-segment seg)))
    (make-point
     (avg (x-point start) (x-point end))
     (avg (y-point start) (y-point end)))))

(midpoint-segment (make-segment (make-point 1.5 1) (make-point 3 3)))

#+END_SRC

#+RESULTS[570f9497598454887077cc3a12b3fd438abc6bca]:
: (2.25 . 2.0)

*** Exercise 2.3
Implement a representation for rectangles in a plane. (Hint: You may
want to make use of Exercise 2.2.) In terms of your constructors and
selectors, create procedures that compute the perimeter and the area
of a given rectangle. Now implement a different representation for
rectangles. Can you design your system with suitable abstraction
barriers, so that the same perimeter and area procedures will work
using either representation?

#+BEGIN_SRC emacs-lisp :session e-2-2

(defun make-rect (a b c d)
  (cons a (cons b (cons c d))))

(defun square (x) (* x x))

(defun distance (a b)
  (let ((x-a (x-point a))
        (y-a (y-point a))
        (x-b (x-point b))
        (y-b (y-point b)))
    (sqrt (+ (square (- x-a x-b)) (square (- y-a y-b))))))

(defun a-rect (r) (car r))
(defun b-rect (r) (car (cdr r)))
(defun c-rect (r) (car (cdr (cdr r))))
(defun d-rect (r) (cdr (cdr (cdr r))))

(defun peri-rect (r)
  (let ((a (a-rect r))
        (b (b-rect r))
        (c (c-rect r)))
    (* 2 (+ (distance a b) (distance a c)))))

#+END_SRC

#+RESULTS:
: peri-rect

*** Exercise 2.4                                                   :solved:
Here is an alternative procedural representation of pairs. For
this representation, verify that ~(car (cons x y))~ yields ~x~
for any objects ~x~ and ~y~.

#+NAME: e-2-4
#+BEGIN_SRC scheme
(define (z-cons x y)
  (lambda (m) (m x y)))
(define (z-car z)
  (z (lambda (p q) p)))

(z-car (z-cons 1 2))
#+END_SRC

#+RESULTS: e-2-4
: 1

What is the corresponding definition of cdr? (Hint: To verify
that this works, make use of the substitution model of Section
1.1.5.)

**** Answer
For given X and Y, ~(cons X Y)~ equals to
~(lambda (m) X Y)~. Calling ~(car (cons X Y))~, is calling
~((lambda (m) (m X Y)) (lambda (p q) p))~, which is calling
~((lambda (p q) p) X Y)~, and yields X. 
Thus this definition fulfills that:
#+BEGIN_QUOTE
For any objects x and y, if z is ~(cons x y)~ then ~(car z)~
is x and ~(cdr z)~ is y.
#+END_QUOTE

~cdr~ definition:
#+BEGIN_SRC scheme :noweb yes
<<e-2-4>>
(define (z-cdr z)
  (z (lambda (p q) q)))

(z-cdr (z-cons 2 1))
#+END_SRC

#+RESULTS:
: 1

*** Exercise 2.5                                                   :solved:
Show that we can represent pairs of nonnegative integers using
only numbers and arithmetic operations if we represent the pair
a and b as the integer that is the product =2^a * 3^b=. Give the
corresponding definitions of the procedures cons, car, and cdr.

**** Answer
#+BEGIN_SRC scheme
(define (z-cons a b)
  (* (expt 2 a) (expt 3 b)))
(define (z-car p)
  (let-values ([(q r) (quotient/remainder p 2)])
    (cond [(= q 0) 0]
          [(= r 0) (+ (z-car q) 1)]
          [else  0])))
(define (z-cdr p)
  (let-values ([(q r) (quotient/remainder p 3)])
    (cond [(= q 0) 0]
          [(= r 0) (+ (z-cdr q) 1)]
          [else  0])))

(z-car (z-cons 3 4))
#+END_SRC

#+RESULTS:
: 3

*** Exercise 2.6                                                   :solved:
In case representing pairs as procedures wasn’t mind-boggling
enough, consider that, in a language that can manipulate
procedures, we can get by without numbers (at least insofar as
nonnegative integers are concerned) by implementing 0 and the
operation of adding 1 as

#+BEGIN_SRC scheme
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+END_SRC

This is representation is known as /Church numerals/, afterr its
inventor, Alonzo Church, the logician who invented the λ-
calculus.

Define one and two directly (not in terms of zero and add-1).
(Hint: Use substitution to evaluate (add-1 zero)). Give a direct
definition of the addition procedure + (not in terms of repeated
application of add-1).

**** Answer
#+BEGIN_VERSE
Forgive me for using Haskell-style function annotation here.
First we have:

add-1 n = f -> x -> f ((n f) x)
      0 = f -> x -> x

We can get:

1 = add-1 0
  = f -> x -> f ((0 f) x)
  = f -> x -> f x
  
2 = add-1 1
  = f -> x -> f ((1 f) x)
  = f -> x -> f (f x)

We can guess out that:

n = f -> x -> f^n x

add m n = f -> x -> f^m (f^n x)
        = f -> x -> m f (n f x)

Now we have the direct definition of ~add~, that is:

add = m -> n -> f -> x -> m f (n f x)

Validate this:

add 1 1 = f -> x -> 1 f (1 f x)
        = f -> x -> f(f(x))
        = 2
#+END_VERSE

#+BEGIN_SRC scheme
(define one
  (lambda (f)
    (lambda (x)
      (f x))))

(define two
  (lambda (f)
    (lambda (x)
      (f (f x)))))

(define (add m n)
  (lambda (f)
    (lambda (x) ((m f) ((n f) x)))))

;; A validate function
;; As we know n f x = f^n x, if f = this vf, then
;; vf x = vf^n x, so if we call n vf 0, it should simply
;; yields n
(define (vf a) (+ 1 a))

(((add one two) vf) 0)
#+END_SRC

#+RESULTS:
: 3

*** Exercise 2.7                                                   :solved:
#+NAME: e-2-7-a
#+BEGIN_SRC scheme
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
#+END_SRC

Alyssa’s program is incomplete because she has not specified the
implementation of the interval abstraction. Here is a definition
of the interval constructor:

#+NAME: e-2-7-b
#+BEGIN_SRC scheme
(define (make-interval a b) (cons a b))
#+END_SRC

Define selectors upper-bound and lower-bound to complete the
implementation.

**** Answer
#+NAME: e-2-7-c
#+BEGIN_SRC scheme :noweb yes
(define (lower-bound interval)
  (car interval))

(define (upper-bound interval)
  (cdr interval))
#+END_SRC

*** Exercise 2.8                                                   :solved:
Using reasoning analogous to Alyssa’s, describe how the
difference of two intervals may be computed. Define a
corresponding subtraction procedure, called sub-interval.

**** Answer
The difference of two intervals should equal to the first
interval plus the negative of the second interval.

#+NAME: e-2-8
#+BEGIN_SRC scheme :noweb yes
<<e-2-7-a>>
<<e-2-7-b>>
<<e-2-7-c>>

(require racket/format)

(define (show a)
  (~a "[" (lower-bound a) ", " (upper-bound a) "]"))

(define (neg-interval a)
  (make-interval
   (- (upper-bound a))
   (- (lower-bound a))))

(define (sub-interval a b)
  (add-interval a (neg-interval b)))

(neg-interval (make-interval 1 2))
(show (sub-interval (make-interval 1 2)  (make-interval 1 2)))
#+END_SRC

#+RESULTS: e-2-8
: [-1, 1]

*** Exercise 2.9                                                   :solved:
The width of an interval is half of the difference between its
upper and lower bounds. The width is a measure of the
uncertainty of the number specified by the interval. For some
arithmetic operations the width of the result of combining two
intervals is a function only of the widths of the argument
intervals, whereas for others the width of the combination is
not a function of the widths of the argument intervals. Show
that the width of the sum (or difference) of two intervals is a
function only of the widths of the intervals being added (or
subtracted). Give examples to show that this is not true for
multiplication or division.

**** Answer
#+BEGIN_VERSE
For any tow intervals I0 and I1,
if I0 = [a, b]
   I1 = [x, y]
then width(I0) = (b - a) / 2
     width(I1) = (y - x) / 2
width(I0 + I1) = width([a + x, b + y])
               = ((b + y) - (a + x)) / 2
               = (b - a) / 2 + (y - x) / 2
               = width(I0) + width(I1)
Thus width(I0 + I1) = width(I0) + width(I1)

For example, I0 = [0, 0], I1 = [0, 1],
width(I0) = 0, width(I1) = 0.5,
width(I0 * I1) = width([0, 1]) = 0.5 != with(I0) * width(I1)
#+END_VERSE     

*** Exercise 2.10                                                  :solved:
Ben Bitdiddle, an expert systems programmer, looks over Alyssa’s
shoulder and comments that it is not clear what it means to
divide by an interval that spans zero. Modify Alyssa’s code to
check for this condition and to signal an error if it occurs.

**** Answer
#+NAME: e-2-10
#+BEGIN_SRC scheme :noweb yes
<<e-2-8>>

(define (div-interval x y)
  (if (<= (* (lower-bound y) (upper-bound y)) 0)
      (error "Interval Spans Zero")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(show (div-interval (make-interval 1 2) (make-interval 1 1)))
#+END_SRC

#+RESULTS: e-2-10
: [1.0, 2.0]

*** Exercise 2.11                                                  :solved:
In passing, Ben also cryptically comments: “By testing the signs
of the endpoints of the intervals, it is possible to break
mul-interval into nine cases, only one of which requires more
than two multiplications.” Rewrite this procedure using Ben’s
suggestion.

**** Answer
#+NAME: e-2-11
#+BEGIN_SRC scheme :noweb yes
<<e-2-10>>

(define (mul-interval x y)
  (let ((lX (lower-bound x))
        (uX (upper-bound x))
        (lY (lower-bound y))
        (uY (upper-bound y)))
    (cond ((> lX 0) (cond ((> 0 lY) (make-interval (* lX lY) (* uX uY)))
                          ((< 0 uY) (make-interval (* lY uX) (* lX uY)))
                          (else (make-interval (* lY uX) (* uX uY)))))

          ((< lX 0) (cond ((< 0 uY) (make-interval (* uX uY) (* lX lY)))
                          ((> 0 lY) (make-interval (* lX uY) (* uX lY)))
			  (else (make-intervel (* lX uY) (* lx ly)))))

          (else (cond ((> 0 lY) (make-interval (* lX uY) (* uX uY)))
                      ((< 0 uY) (make-intervel (* lY uX) (* lX lY)))
                      (else (make-interval
                             (min (* lX uY) (* lY uX))
                             (max (* lX lY) (* ux uY)))))))))

(show (mul-interval (make-interval -3 -2) (make-interval 2 3)))
#+END_SRC

#+RESULTS: e-2-10-b
: [-6, -6]

*** Exercise 2.12                                                  :solved:
After debugging her program, Alyssa shows it to a potential
user, who complains that her program solves the wrong problem.
He wants a program that can deal with numbers represented as a
center value and an additive tolerance; for example, he wants to
work with intervals such as 3.5 ± 0.15 rather than [3.35, 3.65].
Alyssa returns to her desk and fixes this problem by supplying
an alternate constructor and alternate selectors:

#+NAME: e-2-12-a
#+BEGIN_SRC scheme
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

Unfortunately, most of Alyssa’s users are engineers. Real
engineering situations usually involve measurements with only a
small uncertainty, measured as the ratio of the width of the
interval to the midpoint of the interval. Engineers usually
specify percentage tolerances on the parameters of devices, as
in the resistor specifications given earlier.

Define a constructor ~make-center-percent~ that takes a center
and a percentage tolerance and produces the desired interval.
You must also define a selector ~percent~ that produces the
percentage tolerance for a given interval. The ~center~ selector
is the same as the one shown above.

**** Answer
#+NAME: e-2-12-b
#+BEGIN_SRC scheme :noweb yes
<<e-2-11>>
<<e-2-12-a>>

(define (make-center-percent c p)
  (make-center-width c (* (abs c) (/ p 100))))

(define (percent a)
  (* (/ (width a) (center a)) 100))

(show (make-center-percent 1 50))
(percent (make-center-percent 1 50))
#+END_SRC

#+RESULTS:
: 50

*** Exercise 2.13                                                  :solved:
Show that under the assumption of small percentage tolerances
there is a simple formula for the approximate percentage
tolerance of the product of two intervals in terms of the
tolerances of the factors. You may simplify the problem by
assuming that all numbers are positive.

**** Answer
#+BEGIN_VERSE
For any two intervals I0 and I1,

I0 = C0 ± P0 = [C0 - C0 * P0, C0 + C0 * P0]
I1 = C1 ± P1 = [C1 - C1 * P1, C1 + C1 * P1]

For All numbers are positive,

I = I0 * I1 
I = C ± P
C = C0 * C1 + P0 * P1
P = C0 * P1 + C1 * P0

R = P / C = (C0 * P1 + C1 * P0) / (C0 * C1 + P0 * P1)
  = (C0 / P0 + C1 / P1) / ((C0 * C1) / (P0 * P1) + 1)
  = (R0 + R1) / (R0 * R1 + 1)
#+END_VERSE

*** Exercise 2.14
After considerable work, Alyssa P. Hacker delivers her finished
system. Several years later, after she has forgotten all about
it, she gets a frenzied call from an irate user, Lem E. Tweakit.
It seems that Lem has noticed that the formula for parallel
resistors can be written in two algebraically equivalent ways:
=(R1 * R2) / (R1 + R2)= and =1 / (1 / R1 + 1 / R2)=.

He has written the following two programs, each of which
computes the parallel-resistors formula differently:

#+NAME: e-2-13
#+BEGIN_SRC scheme
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
#+END_SRC

Lem complains that Alyssa’s program gives different answers for
the two ways of computing. Thisis is a serious complaint.

Demonstrate that Lem is right. Investigate the behavior of the
system on a variety of arithmetic expressions. Make some
intervals A and B, and use them in computing the expressions
=A / A= and =A / B=. You will get the most insight by using
intervals whose width is a small percentage of the center value.
Examine the results of the computation in center-percent form
(see Exercise 2.12).

*** Exercise 2.15
Eva Lu Ator, another user, has also noticed the different
intervals computed by different but algebraically equivalent
expressions. She says that a formula to compute with intervals
using Alyssa’s system will produce tighter error bounds if it
can be writtten in such a form that no variable that represents
an uncertain number is repeated. Thus, she says, ~par2~ is a
“better” program for parallel resistances than ~par1~. Is she
right? Why?

*** Exercise 2.16
Explain, in general, why equivalent algebraic expressions may
lead to different answers. Can you devise an interval-arithmetic
package that does not have this shortcoming, or is this task
impossible? (Warning: This is problem is very difficult.)

** 2.2 Hierarchical Data and the Closure Property
*** Exercise 2.17                                                  :solved:
Define a procedure last-pair that returns the
list that contains only the last element of a given (nonempty)
list:

#+BEGIN_SRC racket
(last-pair (list 23 72 149 34))
(34)
#+END_SRC

**** Answer

#+BEGIN_SRC racket :lang racket
(define (last-pair list)
  (if (null? (cdr list))
      (car list)
      (last-pair (cdr list))))

(last-pair (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: 4

*** Exercise 2.18                                                  :solved:
Define a procedure reverse that takes a list as argument and
returns a list of the same elements in reverse order:

#+BEGIN_SRC racket
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
#+END_SRC

**** Answer

#+BEGIN_SRC racket :lang racket
(define nil '()) 

(define (reverse-iter list result)
  (cond [(null? list) result]
        [(null? (cdr list)) (cons (car list) result)]
        [else (reverse-iter
	       (cdr list) 
	       (cons (car list) result))]))

(define (reverse list)
  (reverse-iter list nil))

(reverse (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 2 | 1 |

*** Exercise 2.19
Consider the change-counting program of Section 1.2.2. It would
be nice to be able to easily change the currency used by the
program, so that we could compute the number of ways to change a
British pound, for example. As the program is written, the
knowledge of the currency is distributed partly into the
procedure ~first-denomination~ and partly into the procedure
~count-change~ (which knows that there are five kinds of U.S.
coins). It would be nicer to be able to supply a list of coins
to be used for making change.

We want to rewrite the procedure cc so that its second argument
is a list of the values of the coins to use rather than an
integer specifying which coins to use. We could then have lists
that defined each kind of currency:

#+BEGIN_SRC racket :lang racket
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

We could then call cc as follows:

#+BEGIN_SRC racket :lang racket
(cc 100 us-coins)
#+END_SRC

To do this will require changing the program =cc= somewhat. It
will still have the same form, but it will access its second
argument differently, as follows:

#+BEGIN_SRC racket :lang racket
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))
#+END_SRC

Define the procedures ~first-denomination~, ~except-first-
denomination~, and ~no-more?~ in terms of primitive operations
on list structures. Does the order of the list ~coin-values~
affect the answer produced by ~cc~? Why or why not?

*** Exercise 2.20                                                  :solved:
The procedures ~+~, ~*~, and ~list~ take arbitrary numbers of
arguments. One way to define such procedures is to use ~define~
with /dotted-tail/ notation. In a procedure definition, a
parameter list that has a dot before the last parameter name
indicates that, when the procedure is called, the initial
parameters (if any) will have as values the initial arguments,
as usual, but the final parameter’s value will be a list of any
remaining arguments. For instance, given the definition

#+BEGIN_SRC racket
(define (f x y . z) ⟨body⟩)
#+END_SRC

the procedure ~f~ can be called with two or more arguments. If
we evaluate

#+BEGIN_SRC racket
(f 1 2 3 4 5 6)
#+END_SRC

then in the body of ~f~, ~x~ will be 1, ~y~ will be 2, and z
will be the list ~(3 4 5 6)~. Given the definition

#+BEGIN_SRC racket
(define (g . w) ⟨body⟩)
#+END_SRC

the procedure ~g~ can be called with zero or more arguments. If
we evaluate

#+BEGIN_SRC racket
(g 1 2 3 4 5 6)
#+END_SRC

then in the body of ~g~, ~w~ will be the list ~(1 2 3 4 5 6)~.

To define ~f~ and ~g~ using lambda we would write

#+BEGIN_SRC racket
(define f (lambda (x y . z) ⟨body⟩))
(define g (lambda w ⟨body⟩))
#+END_SRC


Use this notation to write a procedure ~same-parity~ that takes
one or more integers and returns a list of all the arguments
that have the same even-odd parity as the first argument. For
example,

#+BEGIN_SRC racket
(same-parity 1 2 3 4 5 6 7) (1 3 5 7)
(same-parity 2 3 4 5 6 7) (2 4 6)
#+END_SRC

**** Answer

#+BEGIN_SRC racket :lang racket
(define (same-parity-iter parity lst)
  (cond [(empty? lst) lst]
        [(eq? (remainder (car lst) 2) parity)
         (cons (car lst) (same-parity-iter parity (cdr lst)))]
        [else (same-parity-iter parity (cdr lst))]))

(define (same-parity . l)
  (same-parity-iter (remainder (car l) 2) l))

(same-parity 1 2 3 4 5)
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 |

*** Exercise 2.21                                                  :solved:
The procedure ~square-list~ takes a list of numbers as
argument and returns a list of the squares of those numbers.

#+BEGIN_SRC racket
(square-list (list 1 2 3 4))
(1 4 9 16)
#+END_SRC

Here are two different definitions of ~square-list~. Complete
both of them by filling in the missing expressions:

#+BEGIN_SRC racket
(define (square-list items)
  (if (null? items)
      nil
      (cons ⟨??⟩ ⟨??⟩)))

(define (square-list items)
  (map ⟨??⟩ ⟨??⟩))
#+END_SRC

**** Answer

#+BEGIN_SRC racket :lang racket
(define (square-list items)
  (if (null? items)
      '()
      (cons (* (car items) (car items)) (square-list (cdr items)))))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

#+BEGIN_SRC racket :lang racket
(define (square-list items)
  (map (lambda (n) (* n n)) items))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

*** Exercise 2.22                                                  :solved:
Louis Reasoner tries to rewrite the first ~square-list~
procedure of [[Exercise 2.21]] so that it evolves an iterative
process:

#+BEGIN_SRC racket
(define (square-list items)
  (define (iter things answer)
    (if (null? things) answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+END_SRC

Unfortunately, defining ~square-list~ this way produces the
answer list in the reverse order of the one desired. Why?

Louis then tries to fix his bug by interchanging the arguments
to ~cons~:

#+BEGIN_SRC racket
(define (square-list items)
  (define (iter things answer) (if (null? things)
                                   answer
                                   (iter (cdr things)
                                         (cons answer
                                               (square (car things))))))
  (iter items nil))
#+END_SRC

This doesn’t work either. Explain.

**** Answer
Because when you do ~(cons (square (car things)) answer)~, you
are putting ~(square (car things))~ to the head of answer. It
will act like a 'FILO' stack.

For the second program, ~answer~ is a list, however
~(square (car things))~ is a number, ~(cons list number)~
creates a structure like ~(((nil . 1) . 4) . 9)~, which is not
a list.


*** Exercise 2.23                                                  :solved:
procedure ~for-each~ is similar to map. It takes as arguments a
procedure and a list of elements. However, rather than forming a
list of the results, ~for-each~ just applies the procedure to
each of the elements in turn, from left to right. The values
returned by applying the procedure to the elements are not used
at all— ~for-each~ is used with procedures that perform an
action, such as printing. For example,

#+BEGIN_SRC scheme
(for-each (lambda (x)
	    (newline)
	    (display x))
          (list 57 321 88))
57
321
88
#+END_SRC

The value returned by the call to for-each (not illustrated
above) can be something arbitrary, such as true. Give an
implementation of ~for-each~.

**** Answer

#+BEGIN_SRC racket :lang racket
(define (for-each f lst)
  (if (empty? lst)
      #t
      (begin
        (f (car lst))
        (for-each f (cdr lst)))))

(for-each (lambda (x) (display x)) (list 57 321 88))
#+END_SRC

#+RESULTS:
: 5732188#t

*** Exercise 2.24                                                  :solved:
Suppose we evaluate the expression
~(list 1 (list 2 (list 3 4)))~. Give the result printed by the
interpreter, the corresponding box-and-pointer structure, and
the interpretation of this as a tree (as in Figure 2.6).

**** Answer
The output is:
#+BEGIN_SRC racket :lang racket
(1 . ((2 . ((3 . (4 . nil)) . nil) ) . nil)
#+END_SRC

The box and pointer graph:
#+BEGIN_VERSE
[ 1 | -] -> [ ↓ | nil ]
            [ 2 | -] -> [ ↓ | nil ]
                        [ 3 | -] -> [ 4 | nil]
#+END_VERSE

The tree graph:
#+BEGIN_VERSE
 .
 |-+
 1 |-+-+
   2 | |
     3 4
#+END_VERSE 

*** Exercise 2.25                                                  :solved:
Give combinations of ~cars~ and ~cdrs~ that will pick 7 from
each of the following lists:

#+BEGIN_SRC racket
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+END_SRC

**** Answer

#+BEGIN_SRC racket :lang racket
(define (solve l)
  (cadr (caddr l)))

(solve (list 1 3 (list 5 7) 9))
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC racket :lang racket
(define (solve l)
  (car (car l)))

(solve (list (list 7)))
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC racket :lang racket
(define (solve l)
  (cadr (cadr (cadr (cadr (cadr (cadr l)))))))

(solve (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
#+END_SRC

#+RESULTS:
: 7

*** Exercise 2.26                                                  :solved:
Suppose we define ~x~ and ~y~ to be two lists:

#+NAME: e-2-26-a
#+BEGIN_SRC racket
(define x (list 1 2 3))
(define y (list 4 5 6))
#+END_SRC

What result is printed by the interpreter in response to
evaluating each of the following expressions:

#+NAME: e-2-26-b
#+BEGIN_SRC racket
(append x y)
(cons x y)
(list x y)
#+END_SRC

**** Answer
The output is:

#+BEGIN_SRC racket
(list 1 2 3 4 5 6)
((list 1 2 3) . (list 4 5 6))
((list 1 2 3) . ((list 4 5 6) . nil))
#+END_SRC

To check it:

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(append x y)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 |

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(cons x y)
#+END_SRC

#+RESULTS:
| (1 2 3) | 4 | 5 | 6 |

#+BEGIN_SRC racket :lang racket :noweb yes
<<e-2-26-a>>
(list x y)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
| 4 | 5 | 6 |

*** Exercise 2.27                                                  :solved:
Modify your ~reverse~ procedure of [[Exercise 2.18]] to produce a
~deep-reverse~ procedure that takes a list as argument and
returns as its value the list with its elements reversed and
with all sublists deep-reversed as well. For example,

#+BEGIN_SRC racket
(define x (list (list 1 2) (list 3 4)))
x
((1 2) (3 4))
(reverse x)
((3 4) (1 2))
(deep-reverse x) ((4 3) (2 1))
#+END_SRC

**** Answer

#+BEGIN_SRC racket
(define (reverse-iter lst reversed)
  (cond [(empty? lst) reversed]
        [(empty? (cdr lst))
         (if (pair? (car lst))
             (cons (reverse-iter (car lst) '()) reversed)
             (cons (car lst) reversed))]
        [else
         (if (pair? (car lst))
             (reverse-iter (cdr lst) 
                           (cons (reverse-iter (car lst) '()) reversed))
             (reverse-iter (cdr lst) (cons (car lst) reversed)))]))

(define (deep-reverse lst) (reverse-iter lst '()))

(deep-reverse (list 1 (list 2 3) 4 5 (list 6 7 8)) )

#+END_SRC

#+RESULTS:
| (8 7 6) | 5 | 4 | (3 2) | 1 |

*** Exercise 2.28                                                  :solved:
Write a procedure ~fringe~ that takes as argument a tree (
represented as a list) and returns a list whose elements are all
the leaves of the tree arranged in left-to-right order. For
example,

#+BEGIN_SRC racket
(define x (list (list 1 2) (list 3 4))) (fringe x)
(1 2 3 4)
(fringe (list x x))
(1 2 3 4 1 2 3 4)
#+END_SRC

**** Answer

#+BEGIN_SRC racket
(define (fringe-iter tree result)
  (cond [(empty? tree) result]
        [(pair? (car tree))
         (append (append result (fringe-iter (car tree) '())) 
                 (fringe-iter (cdr tree) '()))]
        [else (fringe-iter (cdr tree) (append result (list (car tree))))]))

(define (fringe tree)
  (fringe-iter tree '()))

(fringe (list (list 1 2) 3 (list 4 5)))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

*** Exercise 2.29                                                  :solved:
A binary mobile consists of two branches, a left branch and a
right branch. Each branch is a rod of a certain length, from
which hangs either a weight or another binary mobile. We can
represent a binary mobile using compound data by constructing it
from two branches (for example, using ~list~):

#+NAME: e-2-29-a
#+BEGIN_SRC racket
(define (make-mobile left right)
  (list left right))
#+END_SRC

A branch is constructed from a length (which must be a number)
together with a structure, which may be either a number (
representing a simple weight) or another mobile:

#+NAME: e-2-29-b
#+BEGIN_SRC racket
(define (make-branch length structure)
  (list length structure))
#+END_SRC

a. Write the corresponding selectors ~left-branch~ and
~right-branch~, which return the branches of a mobile, and
~branch-length~ and ~branch-structure~, which return the
components of a branch.

b. Using your selectors, define a procedure ~total-weight~ that
returns the total weight of a mobile.

c. A mobile is said to be /balanced/ if the torque applied by
its top-left branch is equal to that applied by its top-right
branch (that is, if the length of the left rod multiplied by the
weight hanging from that rod is equal to the corresponding
product for the right side) and if each of the submobiles
hanging off its branches is balanced. Design a predicate that
tests whether a binary mobile is balanced.

d. Suppose we change the representation of mobiles so that the
constructors are

#+NAME: e-2-29-c
#+BEGIN_SRC racket
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
#+END_SRC

How much do you need to change your programs to convert to the
new representation?

**** Answer
***** a
#+NAME: e-2-29-d
#+BEGIN_SRC racket
(define (left-branch mob) (car mob))
(define (right-branch mob) (cadr mob))
(define (branch-length brn) (car brn))
(define (branch-structure brn) (cadr brn))
#+END_SRC

***** b
#+NAME: e-2-29-e
#+BEGIN_SRC racket
<<e-2-29-a>>
<<e-2-29-b>>
<<e-2-29-d>>

(define (brn-weight brn)
  (let ([strc (branch-structure brn)])
    (if (number? strc)
        strc
        (total-weight strc))))

(define (total-weight mob)
  (+
   (brn-weight (left-branch mob))
   (brn-weight (right-branch mob))))

(total-weight
 (make-mobile
  (make-branch 1 2)
  (make-branch
   3
   (make-mobile (make-branch 7 8) (make-branch 9 10)))))
#+END_SRC

#+RESULTS: e-2-29-e
: 20

***** c
#+NAME: e-2-29-f
#+BEGIN_SRC racket
<<e-2-29-e>>

(define (brn-balanced? brn)
  (let ([strc (branch-structure brn)])
    (if (number? strc)
        #t
        (balanced? strc))))

(define (torque brn)
  (* (branch-length brn) (brn-weight brn)))

(define (balanced? mob)
  (and
   (= (torque (left-branch mob))
      (torque (right-branch mob)))
   (brn-balanced? (left-branch mob))
   (brn-balanced? (right-branch mob))))

(balanced?
 (make-mobile
  (make-branch 1 20)
  (make-branch 2
               (make-mobile
                (make-branch 1 5)
                (make-branch 1 5)))))
#+END_SRC

#+RESULTS: e-2-29-f
: #t

***** d
I only need to change the selectors and constructors, which
are ~left-branch~, ~right-branch~, ~branch-length~ and
~branch-structure~ functions.

*** Exercise 2.30                                                  :solved:
Define a procedure ~square-tree~ analogous to the ~square-list~
procedure of [[Exercise 2.21]]. That is, ~square-tree~ should behave
as follows:

#+BEGIN_SRC racket
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
(1 (4 (9 16) 25) (36 49))
#+END_SRC

Define ~square-tree~ both directly (i.e., without using any
higher-order procedures) and also by using map and recursion.

**** Answer
Implement directly:

#+BEGIN_SRC racket
(define (square n) (* n n))

(define (square-tree tree)
  (cond [(empty? tree) '()]
        [(not (pair? tree)) (square tree)]
        [else (cons (square-tree (car tree))
                    (square-tree (cdr tree)))]))

(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

Implement with ~map~:

#+BEGIN_SRC racket
(define (square n) (* n n))

(define (square-tree tree)
  (map (lambda (sub)
         (if (pair? sub)
             (square-tree sub)
             (square sub)))
       tree))

(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
#+END_SRC

#+RESULTS:
| 1 | (4 (9 16) 25) | (36 49) |

*** Exercise 2.31                                                  :solved:
Abstract your answer to [[Exercise 2.30]] to produce a procedure
~tree-map~ with the property that ~square-tree~ could be defined
as

#+NAME: e-2-31-a
#+BEGIN_SRC racket
(define (square-tree tree) (tree-map square tree))
#+END_SRC

**** Answer

#+BEGIN_SRC racket
<<e-2-31-a>>

(define (square n) (* n n))

(define (tree-map f tree)
  (map (lambda (sub)
         (if (pair? sub)
             (tree-map f sub)
             (f sub)))
       tree))

(square-tree (list 1 2 (list 3 4)))
#+END_SRC

#+RESULTS:
| 1 | 4 | (9 16) |

*** Exercise 2.32                                                  :solved:
We can represent a set as a list of distinct elements, and we
can represent the set of all subsets of the set as a list of
lists. For example, if the set is ~(1 2 3)~, then the set of all
subsets is ~(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))~.
Complete the following definition of a procedure that generates
the set of subsets of a set and give a clear explanation of why
it works:

#+BEGIN_SRC racket
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map ⟨??⟩ rest)))))
#+END_SRC

**** Answer

#+BEGIN_SRC racket
(define nil '())

(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))])
        (append rest (map (lambda (n) (cons (car s) n)) rest)))))

(subsets (list 1 2 3))
#+END_SRC

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

*** Exercise 2.33                                                  :solved: 
Fill in the missing expressions to complete the following
definitions of some basic list-manipulation operations as
accumulations:

#+BEGIN_SRC racket
(define (map p sequence)
  (accumulate (lambda (x y) ⟨??⟩) nil sequence))
(define (append seq1 seq2)
  (accumulate cons ⟨??⟩ ⟨??⟩))
(define (length sequence)
  (accumulate ⟨??⟩ 0 sequence))
#+END_SRC

**** Answer
Just put the definition of ~accumulate~ here:

#+NAME: e-2-33-a
#+BEGIN_SRC racket
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
#+END_SRC

#+BEGIN_SRC racket
<<e-2-33-a>>

(define (map p sequence)
  (accumulate
   (lambda (x y) (cons (p x) y))
   '()
   sequence))

(map (lambda (n) (+ 1 n)) (list 1 2 3))
#+END_SRC

#+RESULTS:
| 2 | 3 | 4 |

#+BEGIN_SRC racket
<<e-2-33-a>>

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(append (list 1 2) (list 3 4))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 |

#+BEGIN_SRC racket
<<e-2-33-a>>

(define (length sequence)
  (accumulate (lambda (e n) (+ 1 n)) 0 sequence))

(length (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: 4

*** Exercise 2.34                                                  :solved:
Evaluating a polynomial in x at a given value of x can be
formulated as an accumulation. We evaluate the polynomial

#+BEGIN_CENTER
a_{n}x^{n} + a_{n-1}x^{n-1} + ... + a_{1}x + a_{0}
#+END_CENTER

using a well-known algorithm called /Horner’s rule/, which
structures the computation as

#+BEGIN_CENTER
(...(a_{n}x + a_{n-1})x + ... + a_{1})x + a_{0}.
#+END_CENTER

In other words, we start with a_{n}, multiply by x, add a_{n-1},
multiply by x, and so on, until we reach a_{0}.

Fill in the following template to produce a procedure that
evaluates a polynomial using Horner’s rule. Assume that the
coefficients of the polynomial are arranged in a sequence, from
a_{0} through a_{n}.

#+BEGIN_SRC racket
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) ⟨??⟩)
              0
              coefficient-sequence))
#+END_SRC

For example, to compute 1 + 3x + 5x^{3} + x^{5} at x = 2
you would evaluate

#+BEGIN_SRC racket
(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

**** Answer

#+BEGIN_SRC racket
<<e-2-33-a>>

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff (* higher-terms x)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+RESULTS:
: 79


*** Exercise 2.35
Redefine ~count-leaves~ from Section 2.2.2 as an accumulation:

#+BEGIN_SRC racket
(define (count-leaves t)
  (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
#+END_SRC
